{
  "global": {
    "documentation": "字符串处理环境的全局函数和变量。",
    "methods": [
      {
        "name": "input_string",
        "signature": "input_string: string",
        "documentation": "【只读】输入的字符串。这是符文的主要处理对象。",
        "kind": "Variable"
      },
      {
        "name": "set_output",
        "signature": "set_output(value: any): void",
        "documentation": "设置符文的输出结果。任何类型的值都会被转换为字符串。\n\n**示例:**\n```lua\nset_output('处理完成: ' .. input_string)\n```",
        "insertText": "set_output(${1:value})"
      }
    ]
  },
  "log": {
    "documentation": "全局日志对象，用于在调试输出中记录信息。",
    "methods": [
      {
        "name": "info",
        "signature": "log.info(message: string): void",
        "documentation": "记录一条信息级别的日志。\n\n**示例:**\n```lua\nlog.info(\"处理用户数据...\")\n```",
        "insertText": "info('${1:message}')"
      },
      {
        "name": "warn",
        "signature": "log.warn(message: string): void",
        "documentation": "记录一条警告级别的日志。\n\n**示例:**\n```lua\nlog.warn(\"某个字段值为空\")\n```",
        "insertText": "warn('${1:message}')"
      },
      {
        "name": "error",
        "signature": "log.error(message: string): void",
        "documentation": "记录一条错误级别的日志。\n\n**示例:**\n```lua\nlog.error(\"无法连接到数据库\")\n```",
        "insertText": "error('${1:message}')"
      }
    ]
  },
  "json": {
    "documentation": "全局 JSON 处理对象，用于 Lua 值与 JSON 字符串之间的相互转换。基于 rxi/json.lua 库，行为符合 JSON 标准。",
    "methods": [
      {
        "name": "encode",
        "signature": "json.encode(value: table | any): string",
        "documentation": "将一个 Lua 值（例如 table, string, number, boolean, nil）序列化为 JSON 字符串。\n\n**特性:**\n- 自动区分数组和对象。\n- 正确处理字符串转义。\n- 会因循环引用而报错。\n\n**示例:**\n```lua\nlocal user = { id = 1, name = \"Alice\", roles = {\"admin\", \"editor\"} }\nlocal user_json = json.encode(user)\n-- user_json 的值为 '{\"id\":1,\"name\":\"Alice\",\"roles\":[\"admin\",\"editor\"]}'\n```",
        "insertText": "encode(${1:lua_value})"
      },
      {
        "name": "decode",
        "signature": "json.decode(jsonString: string): table | any",
        "documentation": "将一个 JSON 字符串反序列化为等效的 Lua 值。\n\n**特性:**\n- 能解析复杂的嵌套对象和数组。\n- 严格遵守 JSON 格式，对于无效的 JSON 字符串会报错。\n\n**示例:**\n```lua\nlocal json_str = '{\"id\":1,\"name\":\"Alice\",\"is_active\":true,\"metadata\":null}'\nlocal user_data = json.decode(json_str)\n\nlog.info('用户名: ' .. user_data.name) -- 输出 'Alice'\nlog.info('是否激活: ' .. tostring(user_data.is_active)) -- 输出 'true'\nif user_data.metadata == nil then\n  log.info('元数据为空')\nend\n```",
        "insertText": "decode('${1:json_string}')"
      }
    ]
  },
  "regex": {
    "documentation": "全局正则表达式对象，用于字符串匹配。",
    "methods": [
      {
        "name": "is_match",
        "signature": "regex.is_match(input: string, pattern: string): boolean",
        "documentation": "检查输入字符串是否匹配指定的正则表达式模式。\n\n**示例:**\n```lua\nlocal is_email = regex.is_match(\"test@example.com\", \"^%S+@%S+%.%S+$\")\n```",
        "insertText": "is_match('${1:input}', '${2:pattern}')"
      },
      {
        "name": "match",
        "signature": "regex.match(input: string, pattern: string): string | nil",
        "documentation": "返回输入字符串中第一个匹配正则表达式的子串。\n\n**示例:**\n```lua\nlocal text = \"用户ID是: 12345\"\nlocal user_id = regex.match(text, \"%d+\") -- 返回 \"12345\"\n```",
        "insertText": "match('${1:input}', '${2:pattern}')"
      },
      {
        "name": "match_all",
        "signature": "regex.match_all(input: string, pattern: string): table",
        "documentation": "返回一个包含所有匹配项的 table。\n\n**示例:**\n```lua\nlocal text = \"我有 2 个苹果和 3 个香蕉\"\nlocal numbers = regex.match_all(text, \"%d+\")\n-- numbers table 将是 { \"2\", \"3\" }\nfor i, num in ipairs(numbers) do\n  log.info(num)\nend\n```",
        "insertText": "match_all('${1:input}', '${2:pattern}')"
      }
    ]
  },
  "datetime": {
    "documentation": "全局日期时间处理对象。用于获取、解析和操作日期时间。",
    "methods": [
      {
        "name": "utcnow",
        "signature": "datetime.utcnow(): DateTimeObject",
        "documentation": "获取当前的 UTC (协调世界时) 时间，并返回一个 DateTimeObject。\n\n**返回的对象拥有以下属性和方法:**\n- **属性:** `.year`, `.month`, `.day`, `.hour`, `.minute`, `.second`, `.millisecond`, `.day_of_week`, `.day_of_year`\n- **方法:** `.format(fmt)`, `.add_days(n)`, `.add_hours(n)`, 等。\n\n**示例:**\n```lua\nlocal now = datetime.utcnow()\nlog.info('Current year: ' .. now.year)\nctx.set('iso_time', now:format('o'))\n```",
        "insertText": "utcnow()"
      },
      {
        "name": "now",
        "signature": "datetime.now(): DateTimeObject",
        "documentation": "获取当前服务器的本地时间，并返回一个 DateTimeObject。**注意:** 为避免时区问题，推荐在大多数场景下使用 `utcnow()`。",
        "insertText": "now()"
      },
      {
        "name": "parse",
        "signature": "datetime.parse(dateString: string, format?: string): DateTimeObject | nil",
        "documentation": "将字符串解析为 DateTimeObject。\n- 如果 `format` 省略，会尝试解析标准 ISO 8601 格式。\n- 如果提供了 `format`，则会按指定的 .NET 格式字符串进行解析。\n- 如果解析失败，返回 `nil`。\n\n**.NET 格式化参考:**\n- `yyyy`: 四位年份\n- `MM`: 月份 (01-12)\n- `dd`: 日期 (01-31)\n- `HH`: 24小时制小时 (00-23)\n- `mm`: 分钟 (00-59)\n- `ss`: 秒 (00-59)\n\n**示例:**\n```lua\n-- ISO 解析\nlocal event_time = datetime.parse('2024-01-01T12:00:00Z')\n\n-- 自定义格式解析\nlocal log_time = datetime.parse('2024/01/01 14:30', 'yyyy/MM/dd HH:mm')\nif log_time then\n  log.info('Log hour: ' .. log_time.hour)\nend\n```",
        "insertText": "parse('${1:dateString}', '${2:format}')"
      }
    ]
  }
}