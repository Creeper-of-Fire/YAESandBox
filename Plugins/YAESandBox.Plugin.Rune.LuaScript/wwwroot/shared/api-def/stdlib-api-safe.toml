[global]
documentation = "Lua 全局函数，可直接调用。"

[[global.methods]]
name = "assert"
signature = "assert(v: any, message?: string): any"
documentation = """
检查第一个参数 `v` 是否为真（非 `false` 且非 `nil`）。

- 如果为假，则抛出一个错误。错误信息为 `message`，如果未提供，则默认为 "assertion failed!"。
- 如果为真，则返回所有参数。

**示例:**
```lua
assert(type(x) == "number", "x 必须是一个数字")
```"""
insertText = "assert(${1:condition}, ${2:message})"

[[global.methods]]
name = "collectgarbage"
signature = "collectgarbage(opt?: string, arg?: any): any"
documentation = """
垃圾回收器接口。根据 `opt` 选项执行不同的功能，如启动、停止、重启或获取内存使用情况。

**示例:**
```lua
-- 打印当前使用的内存（KB）
print(collectgarbage("count"))
```"""
insertText = 'collectgarbage("${1:opt}")'

[[global.methods]]
name = "error"
signature = "error(message: any, level?: integer): never"
documentation = """
终止当前函数的执行，并抛出一个错误。`message` 是错误信息。
`level` 指明了报告错误的调用栈层级。

**示例:**
```lua
error("发生了严重错误", 2)
```"""
insertText = "error(${1:message}, ${2:level})"

[[global.methods]]
name = "getmetatable"
signature = "getmetatable(object: any): table | nil"
documentation = """
返回给定 `object` 的元表（metatable）。如果对象没有元表，或其元表有 `__metatable` 字段，则返回 `nil`。

**示例:**
```lua
local mt = getmetatable("a string")
```"""
insertText = "getmetatable(${1:object})"

[[global.methods]]
name = "ipairs"
signature = "ipairs(t: table): (function, table, integer)"
documentation = """
返回一个迭代器函数，用于在 `for` 循环中遍历表 `t` 的整数键（1, 2, 3, ...）。

**示例:**
```lua
local t = {"a", "b", "c"}
for index, value in ipairs(t) do
  print(index, value)
end
```"""
insertText = "ipairs(${1:table})"

[[global.methods]]
name = "load"
signature = "load(chunk: string | function, chunkname?: string, mode?: string, env?: table): function | (nil, string)"
documentation = """
加载一个代码块（`chunk`），但不执行它。返回编译后的函数，或在失败时返回 `nil` 和错误信息。

**示例:**
```lua
local func, err = load("return 1 + 2")
if func then print(func()) end
```"""
insertText = "load(${1:chunk})"

[[global.methods]]
name = "next"
signature = "next(t: table, index?: any): (any, any) | nil"
documentation = """
允许程序遍历一个表的所有字段。给定一个键 `index`，返回表中的下一个键值对。初始调用时 `index` 为 `nil`。

**示例:**
```lua
local t = {a = 1, b = 2}
local k, v = next(t, nil)
while k do
  print(k, v)
  k, v = next(t, k)
end
```"""
insertText = "next(${1:table}, ${2:index})"

[[global.methods]]
name = "pairs"
signature = "pairs(t: table): (function, table, nil)"
documentation = """
返回一个迭代器函数（通常是 `next`），用于在 `for` 循环中遍历表 `t` 的所有键值对。

**示例:**
```lua
local t = {name = "Lua", version = 5.4}
for key, value in pairs(t) do
  print(key, value)
end
```"""
insertText = "pairs(${1:table})"

[[global.methods]]
name = "pcall"
signature = "pcall(f: function, ...args): (boolean, ...results)"
documentation = """
以“保护模式”（Protected Call）调用函数 `f`。如果 `f` 执行无误，返回 `true` 和 `f` 的所有返回值。如果发生错误，返回 `false` 和错误信息。

**示例:**
```lua
local ok, result = pcall(function() return 10 / 0 end)
if not ok then print("错误:", result) end
```"""
insertText = "pcall(${1:func}, ${2:...args})"

[[global.methods]]
name = "print"
signature = "print(...: any): void"
documentation = """
接收任意数量的参数，并将它们的值输出到标准输出。它会用制表符分隔每个参数，并在最后输出一个换行符。

**示例:**
```lua
print("Hello", "World", 123)
```"""
insertText = "print(${1:...args})"

[[global.methods]]
name = "rawequal"
signature = "rawequal(v1: any, v2: any): boolean"
documentation = """
在不触发任何元方法（`__eq`）的情况下，比较 `v1` 和 `v2` 是否相等。

**示例:**
```lua
if rawequal(a, b) then ... end
```"""
insertText = "rawequal(${1:v1}, ${2:v2})"

[[global.methods]]
name = "rawget"
signature = "rawget(t: table, index: any): any"
documentation = """
在不触发任何元方法（`__index`）的情况下，获取 `t[index]` 的值。

**示例:**
```lua
local val = rawget(my_table, "key")
```"""
insertText = "rawget(${1:table}, ${2:index})"

[[global.methods]]
name = "rawlen"
signature = "rawlen(v: table | string): integer"
documentation = """
在不触发任何元方法（`__len`）的情况下，返回对象 `v` 的长度。

**示例:**
```lua
local len = rawlen("hello") -- 5
```"""
insertText = "rawlen(${1:object})"

[[global.methods]]
name = "rawset"
signature = "rawset(t: table, index: any, value: any): table"
documentation = """
在不触发任何元方法（`__newindex`）的情况下，将 `t[index]` 的值设置为 `value`。

**示例:**
```lua
rawset(my_table, "key", 100)
```"""
insertText = "rawset(${1:table}, ${2:index}, ${3:value})"

[[global.methods]]
name = "select"
signature = "select(index: integer | '#', ...args): any"
documentation = """
如果 `index` 是数字，则返回从该索引开始的所有参数。
如果 `index` 是字符串 `'#'`，则返回可变参数的总数。

**示例:**
```lua
local count = select('#', 1, 2, 3) -- 3
local second_val = select(2, 'a', 'b', 'c') -- 'b'
```"""
insertText = "select(${1:index}, ${2:...args})"

[[global.methods]]
name = "setmetatable"
signature = "setmetatable(t: table, mt: table | nil): table"
documentation = """
为一个表 `t` 设置元表 `mt`。返回表 `t`。

**示例:**
```lua
local t = {}
local mt = { __index = function() return 0 end }
setmetatable(t, mt)
```"""
insertText = "setmetatable(${1:table}, ${2:metatable})"

[[global.methods]]
name = "tonumber"
signature = "tonumber(e: any, base?: integer): number | nil"
documentation = """
尝试将参数 `e` 转换为数字。可以指定一个 `base` (2-36) 来解析字符串。
如果无法转换，返回 `nil`。

**示例:**
```lua
local num1 = tonumber("123")
local num2 = tonumber("FF", 16) -- 255
```"""
insertText = "tonumber(${1:value}, ${2:base})"

[[global.methods]]
name = "tostring"
signature = "tostring(v: any): string"
documentation = """
将任意类型的值 `v` 转换为字符串。如果 `v` 的元表有 `__tostring` 字段，则会调用它来自定义转换逻辑。

**示例:**
```lua
local s = tostring(123) -- "123"
```"""
insertText = "tostring(${1:value})"

[[global.methods]]
name = "type"
signature = "type(v: any): string"
documentation = """
返回一个描述值 `v` 类型的字符串，如 "string", "number", "table", "function" 等。

**示例:**
```lua
print(type({})) -- "table"
```"""
insertText = "type(${1:value})"

[[global.methods]]
name = "warn"
signature = "warn(...: string): void"
documentation = """
发出一个警告信息。警告信息会被发送到标准错误流，但不会中断程序执行。

**示例:**
```lua
warn("警告：这个函数即将被废弃。")
```"""
insertText = "warn(${1:message})"

[[global.methods]]
name = "xpcall"
signature = "xpcall(f: function, msgh: function, ...args): (boolean, ...results)"
documentation = """
与 `pcall` 类似，但在发生错误时，会调用一个指定的错误处理函数 `msgh`。

**示例:**
```lua
local function err_handler(err)
  return "错误: " .. tostring(err)
end
local ok, result = xpcall(my_func, err_handler)
```"""
insertText = "xpcall(${1:func}, ${2:err_handler}, ${3:...args})"

[table]
documentation = "用于操作表的库。"

[[table.methods]]
name = "concat"
signature = "table.concat(list: table, sep?: string, i?: integer, j?: integer): string"
documentation = """
将 `list`（一个序列）中的所有字符串元素连接起来，返回一个单一的字符串。

- `sep` 是可选的分隔符。
- `i` 和 `j` 是可选的起止索引。

**示例:**
```lua
local t = {"a", "b", "c"}
print(table.concat(t, ",")) -- "a,b,c"
```"""
insertText = "concat(${1:list}, ${2:sep})"

[[table.methods]]
name = "insert"
signature = "table.insert(list: table, [pos: integer,] value: any): void"
documentation = """
向 `list`（一个序列）中插入元素 `value`。

- 如果指定了 `pos`，则在 `pos` 位置插入 `value`，并将之后的元素后移。
- 如果未指定 `pos`，则在列表末尾插入 `value`。

**示例:**
```lua
local t = {"a", "b", "c"}
table.insert(t, "d") -- t is now {"a", "b", "c", "d"}
table.insert(t, 1, "z") -- t is now {"z", "a", "b", "c", "d"}
```"""
insertText = "insert(${1:list}, ${2:pos_or_value}, ${3:value_if_pos})"

[[table.methods]]
name = "move"
signature = "table.move(a1: table, f: integer, e: integer, t: integer, a2?: table): table"
documentation = """
将表 `a1` 中从索引 `f` 到 `e` 的元素移动到表 `a2`（默认为 `a1`）的索引 `t` 开始的位置。

**示例:**
```lua
local t1 = {1, 2, 3, 4}
local t2 = {}
table.move(t1, 1, 2, 3, t2) -- t2 is now {nil, nil, 1, 2}
```"""
insertText = "move(${1:source}, ${2:f}, ${3:e}, ${4:t}, ${5:target})"

[[table.methods]]
name = "pack"
signature = "table.pack(...: any): table"
documentation = """
将所有参数打包到一个新表中。新表还会有一个字段 `n`，表示参数的总数。

**示例:**
```lua
local t = table.pack(1, 'a', nil, 'b')
-- t is {1, "a", nil, "b", n = 4}
```"""
insertText = "pack(${1:...args})"

[[table.methods]]
name = "remove"
signature = "table.remove(list: table, pos?: integer): any"
documentation = """
从 `list`（一个序列）中移除一个元素，并返回被移除的元素。

- 如果指定了 `pos`，则移除该位置的元素。
- 如果未指定 `pos`，则移除最后一个元素。

**示例:**
```lua
local t = {"a", "b", "c"}
local removed = table.remove(t) -- removed is "c", t is {"a", "b"}
```"""
insertText = "remove(${1:list}, ${2:pos})"

[[table.methods]]
name = "sort"
signature = "table.sort(list: table, comp?: function): void"
documentation = """
对 `list`（一个序列）进行原地排序。
- `comp` 是一个可选的比较函数，它接收两个参数，当第一个参数应排在第二个之前时返回 `true`。

**示例:**
```lua
local t = {3, 1, 2}
table.sort(t) -- t is now {1, 2, 3}
table.sort(t, function(a, b) return a > b end) -- t is now {3, 2, 1}
```"""
insertText = "sort(${1:list}, ${2:compare_func})"

[[table.methods]]
name = "unpack"
signature = "table.unpack(list: table, i?: integer, j?: integer): ...any"
documentation = """
返回表 `list` 中的元素。通常用于将表中的元素作为函数的参数传递。

**示例:**
```lua
local t = {"hello", "world"}
print(table.unpack(t)) -- prints "hello"  "world"
```"""
insertText = "unpack(${1:list}, ${2:i}, ${3:j})"

[coroutine]
documentation = "用于协程操作的库。"

[[coroutine.methods]]
name = "close"
signature = "coroutine.close(co: thread): (boolean, any)"
documentation = """
关闭一个协程。关闭一个已死的或已关闭的协程会返回 `true`。否则，返回 `false` 和一个错误信息。

**示例:**
```lua
coroutine.close(my_coroutine)
```"""
insertText = "close(${1:co})"

[[coroutine.methods]]
name = "create"
signature = "coroutine.create(f: function): thread"
documentation = """
创建一个新的协程，其主体函数为 `f`。返回一个 `thread` 类型的对象。

**示例:**
```lua
local co = coroutine.create(function()
  print("in coroutine")
end)
```"""
insertText = "create(${1:func})"

[[coroutine.methods]]
name = "isyieldable"
signature = "coroutine.isyieldable(): boolean"
documentation = """
如果当前运行的协程可以被挂起（yield），则返回 `true`。

**示例:**
```lua
if coroutine.isyieldable() then ... end
```"""
insertText = "isyieldable()"

[[coroutine.methods]]
name = "resume"
signature = "coroutine.resume(co: thread, ...args): (boolean, ...results)"
documentation = """
启动或继续执行协程 `co`。返回 `true` 和协程的返回值（或 `yield` 的参数），或在出错时返回 `false` 和错误信息。

**示例:**
```lua
coroutine.resume(co)
```"""
insertText = "resume(${1:co}, ${2:...args})"

[[coroutine.methods]]
name = "running"
signature = "coroutine.running(): (thread, boolean)"
documentation = """
返回当前正在运行的协程和一个布尔值（如果当前是主线程，则为 `true`）。

**示例:**
```lua
local current_co, is_main = coroutine.running()
```"""
insertText = "running()"

[[coroutine.methods]]
name = "status"
signature = "coroutine.status(co: thread): string"
documentation = """
返回协程 `co` 的状态，可能的值为 "running", "suspended", "normal", "dead"。

**示例:**
```lua
print(coroutine.status(co)) -- "suspended"
```"""
insertText = "status(${1:co})"

[[coroutine.methods]]
name = "wrap"
signature = "coroutine.wrap(f: function): function"
documentation = """
创建一个新的协程，并返回一个函数。每次调用该函数时，都会恢复协程的执行。类似于 `coroutine.resume`，但会直接抛出错误。

**示例:**
```lua
local f = coroutine.wrap(function()
  coroutine.yield(1)
  coroutine.yield(2)
end)
print(f()) -- 1
print(f()) -- 2
```"""
insertText = "wrap(${1:func})"

[[coroutine.methods]]
name = "yield"
signature = "coroutine.yield(...: any): ...any"
documentation = """
挂起当前协程的执行。传递给 `yield` 的参数会作为 `coroutine.resume` 的额外返回值。

**示例:**
```lua
coroutine.yield("paused")
```"""
insertText = "yield(${1:...results})"

[utf8]
documentation = "用于处理 UTF-8 编码字符串的库。"

[[utf8.methods]]
name = "char"
signature = "utf8.char(...: integer): string"
documentation = """
接收零个或多个整数，将它们转换为对应的 UTF-8 字符，并返回连接成的字符串。

**示例:**
```lua
print(utf8.char(22, 189, 160)) -- "Lua"
```"""
insertText = "char(${1:...codepoints})"

[[utf8.methods]]
name = "codepoint"
signature = "utf8.codepoint(s: string, i?: integer, j?: integer): ...integer"
documentation = """
返回字符串 `s` 中从位置 `i`到 `j`的所有字符的 code point。

**示例:**
```lua
local cp1, cp2 = utf8.codepoint("你好", 1, 2)
```"""
insertText = "codepoint(${1:s}, ${2:i}, ${3:j})"

[[utf8.methods]]
name = "codes"
signature = "utf8.codes(s: string): function"
documentation = """
返回一个迭代器函数，用于遍历字符串 `s` 中所有字符的 code point。

**示例:**
```lua
for p, c in utf8.codes("你好") do
  print(p, c)
end
```"""
insertText = "codes(${1:s})"

[[utf8.methods]]
name = "len"
signature = "utf8.len(s: string, i?: integer, j?: integer): integer | nil"
documentation = """
返回字符串 `s` 中从字节位置 `i` 到 `j` 的 UTF-8 字符数量。如果遇到无效字节序列，返回 `nil`。

**示例:**
```lua
print(utf8.len("你好")) -- 2
```"""
insertText = "len(${1:s}, ${2:i}, ${3:j})"

[[utf8.methods]]
name = "offset"
signature = "utf8.offset(s: string, n: integer, i?: integer): integer"
documentation = """
返回字符串中第 `n` 个字符的字节偏移量（位置）。

**示例:**
```lua
-- 获取第2个字符开始的字节位置
local byte_pos = utf8.offset("你好世界", 2)
```"""
insertText = "offset(${1:s}, ${2:n}, ${3:i})"

[string]
documentation = "用于字符串操作的库。"

[[string.methods]]
name = "byte"
signature = "string.byte(s: string, i?: integer, j?: integer): ...integer"
documentation = """
返回字符 `s[i]`, `s[i+1]`, ..., `s[j]` 的内部数字编码（字节值）。

**示例:**
```lua
local b1, b2 = string.byte("abc", 1, 2) -- 97, 98
```"""
insertText = "byte(${1:s}, ${2:i}, ${3:j})"

[[string.methods]]
name = "char"
signature = "string.char(...: integer): string"
documentation = """
接收零个或多个整数，并将它们转换为字符，然后连接成一个字符串。

**示例:**
```lua
print(string.char(97, 98, 99)) -- "abc"
```"""
insertText = "char(${1:...bytes})"

[[string.methods]]
name = "dump"
signature = "string.dump(function: function, strip?: boolean): string"
documentation = """
将一个函数序列化为二进制代码块的字符串。`strip` 为真时会移除调试信息。

**示例:**
```lua
local f = function() return 1 end
local dumped = string.dump(f)
```"""
insertText = "dump(${1:func}, ${2:strip})"

[[string.methods]]
name = "find"
signature = "string.find(s: string, pattern: string, init?: integer, plain?: boolean): (integer, integer, ...captures)"
documentation = """
在字符串 `s` 中查找 `pattern` 的第一次匹配。如果找到，返回匹配的起始和结束索引，否则返回 `nil`。

**示例:**
```lua
local i, j = string.find("hello world", "world")
```"""
insertText = 'find(${1:s}, "${2:pattern}", ${3:init})'

[[string.methods]]
name = "format"
signature = "string.format(formatstring: string, ...: any): string"
documentation = """
根据格式化字符串 `formatstring`，返回其余参数的格式化版本。

**示例:**
```lua
local s = string.format("Name: %s, Age: %d", "John", 30)
```"""
insertText = 'format("${1:format}", ${2:...args})'

[[string.methods]]
name = "gmatch"
signature = "string.gmatch(s: string, pattern: string): function"
documentation = """
返回一个迭代器函数，用于遍历字符串 `s` 中所有 `pattern` 的匹配项。

**示例:**
```lua
for word in string.gmatch("hello world from lua", "%a+") do
  print(word)
end
```"""
insertText = 'gmatch(${1:s}, "${2:pattern}")'

[[string.methods]]
name = "gsub"
signature = "string.gsub(s: string, pattern: string, repl: string | table | function, n?: integer): (string, integer)"
documentation = """
返回字符串 `s` 的一个副本，其中所有（或前 `n` 个）`pattern` 的匹配项都被 `repl` 替换。

- `repl` 可以是字符串、table 或函数。
- 返回替换后的字符串和总共发生的替换次数。

**示例:**
```lua
local new_s, count = string.gsub("hello world", "l", "L")
```"""
insertText = 'gsub(${1:s}, "${2:pattern}", ${3:replacement})'

[[string.methods]]
name = "len"
signature = "string.len(s: string): integer"
documentation = """
返回字符串的长度（字节数）。等价于 `#s`。

**示例:**
```lua
print(string.len("hello")) -- 5
```"""
insertText = "len(${1:s})"

[[string.methods]]
name = "lower"
signature = "string.lower(s: string): string"
documentation = """
返回字符串 `s` 的一个副本，其中所有大写字母都转换为小写。

**示例:**
```lua
print(string.lower("Hello World")) -- "hello world"
```"""
insertText = "lower(${1:s})"

[[string.methods]]
name = "match"
signature = "string.match(s: string, pattern: string, init?: integer): ...string"
documentation = """
在字符串 `s` 中查找 `pattern` 的第一次匹配。如果找到，返回模式中的捕获（captures），否则返回 `nil`。

**示例:**
```lua
local name, domain = string.match("user@example.com", "(%S+)@(%S+)")
```"""
insertText = 'match(${1:s}, "${2:pattern}")'

[[string.methods]]
name = "pack"
signature = "string.pack(fmt: string, ...: any): string"
documentation = """
将给定的值打包成一个二进制字符串，格式由 `fmt` 控制。

**示例:**
```lua
local binary_data = string.pack(">I2", 1234)
```"""
insertText = 'pack("${1:format}", ${2:...values})'

[[string.methods]]
name = "packsize"
signature = "string.packsize(fmt: string): integer"
documentation = """
返回给定格式字符串 `fmt` 打包后产生的二进制字符串的长度。

**示例:**
```lua
local size = string.packsize(">I2")
```"""
insertText = 'packsize("${1:format}")'

[[string.methods]]
name = "rep"
signature = "string.rep(s: string, n: integer, sep?: string): string"
documentation = """
返回字符串 `s` 重复 `n` 次并用 `sep` 分隔的字符串。

**示例:**
```lua
print(string.rep("a", 5, ",")) -- "a,a,a,a,a"
```"""
insertText = 'rep(${1:s}, ${2:n}, "${3:sep}")'

[[string.methods]]
name = "reverse"
signature = "string.reverse(s: string): string"
documentation = """
返回字符串 `s` 的反转版本。

**示例:**
```lua
print(string.reverse("hello")) -- "olleh"
```"""
insertText = "reverse(${1:s})"

[[string.methods]]
name = "sub"
signature = "string.sub(s: string, i: integer, j?: integer): string"
documentation = """
返回字符串 `s` 从索引 `i`到 `j` 的子串。

- `i` 和 `j` 可以是负数。
- 如果 `j` 未指定，则默认为 -1 (到字符串末尾)。

**示例:**
```lua
local s = "hello world"
print(string.sub(s, 7))      --> world
print(string.sub(s, 1, 5))    --> hello
print(string.sub(s, -5))     --> world
```"""
insertText = "sub(${1:s}, ${2:i}, ${3:j})"

[[string.methods]]
name = "unpack"
signature = "string.unpack(fmt: string, s: string, pos?: integer): (...any, integer)"
documentation = """
从二进制字符串 `s` 中解包数据，格式由 `fmt` 控制。返回解包后的值和下一个要读取的位置。

**示例:**
```lua
local data = string.pack(">I2", 1234)
local num = string.unpack(">I2", data)
```"""
insertText = 'unpack("${1:format}", ${2:s}, ${3:pos})'

[[string.methods]]
name = "upper"
signature = "string.upper(s: string): string"
documentation = """
返回字符串 `s` 的一个副本，其中所有小写字母都转换为大写。

**示例:**
```lua
print(string.upper("Hello World")) -- "HELLO WORLD"
```"""
insertText = "upper(${1:s})"

[math]
documentation = "数学函数库。"

[[math.methods]]
name = "abs"
signature = "math.abs(x: number): number"
documentation = """
返回 `x` 的绝对值。

**示例:**
```lua
print(math.abs(-10)) -- 10
```"""
insertText = "abs(${1:x})"

[[math.methods]]
name = "acos"
signature = "math.acos(x: number): number"
documentation = """
返回 `x` 的反余弦值（弧度）。

**示例:**
```lua
print(math.acos(0)) -- 1.57079...
```"""
insertText = "acos(${1:x})"

[[math.methods]]
name = "asin"
signature = "math.asin(x: number): number"
documentation = """
返回 `x` 的反正弦值（弧度）。

**示例:**
```lua
print(math.asin(1)) -- 1.57079...
```"""
insertText = "asin(${1:x})"

[[math.methods]]
name = "atan"
signature = "math.atan(y: number, x?: number): number"
documentation = """
返回 `y/x` 的反正切值（弧度）。

- `math.atan(y)`: 返回 `y` 的反正切。
- `math.atan(y, x)`: 使用两个参数的符号来找到象限。

**示例:**
```lua
print(math.atan(1, 1)) -- 0.78539...
```"""
insertText = "atan(${1:y}, ${2:x})"

[[math.methods]]
name = "ceil"
signature = "math.ceil(x: number): number"
documentation = """
返回不小于 `x` 的最小整数值（向上取整）。

**示例:**
```lua
print(math.ceil(3.14)) -- 4
```"""
insertText = "ceil(${1:x})"

[[math.methods]]
name = "cos"
signature = "math.cos(x: number): number"
documentation = """
返回 `x`（弧度）的余弦值。

**示例:**
```lua
print(math.cos(math.pi)) -- -1
```"""
insertText = "cos(${1:x})"

[[math.methods]]
name = "deg"
signature = "math.deg(x: number): number"
documentation = """
将 `x` 从弧度转换为角度。

**示例:**
```lua
print(math.deg(math.pi)) -- 180
```"""
insertText = "deg(${1:x})"

[[math.methods]]
name = "exp"
signature = "math.exp(x: number): number"
documentation = """
返回 e 的 `x` 次幂。

**示例:**
```lua
print(math.exp(1)) -- 2.71828...
```"""
insertText = "exp(${1:x})"

[[math.methods]]
name = "floor"
signature = "math.floor(x: number): number"
documentation = """
返回不大于 `x` 的最大整数值（向下取整）。

**示例:**
```lua
print(math.floor(3.14)) -- 3
```"""
insertText = "floor(${1:x})"

[[math.methods]]
name = "fmod"
signature = "math.fmod(x: number, y: number): number"
documentation = """
返回 `x` 除以 `y` 的余数，该余数的商被截断为零。

**示例:**
```lua
print(math.fmod(5, 2)) -- 1
```"""
insertText = "fmod(${1:x}, ${2:y})"

[[math.methods]]
name = "log"
signature = "math.log(x: number, base?: number): number"
documentation = """
返回 `x` 的对数。`base` 默认为 e（自然对数）。

**示例:**
```lua
print(math.log(100, 10)) -- 2
```"""
insertText = "log(${1:x}, ${2:base})"

[[math.methods]]
name = "max"
signature = "math.max(...: number): number"
documentation = """
返回其参数中的最大值。

**示例:**
```lua
print(math.max(1, 10, -5, 100)) -- 100
```"""
insertText = "max(${1:...numbers})"

[[math.methods]]
name = "min"
signature = "math.min(...: number): number"
documentation = """
返回其参数中的最小值。

**示例:**
```lua
print(math.min(1, 10, -5, 100)) -- -5
```"""
insertText = "min(${1:...numbers})"

[[math.methods]]
name = "modf"
signature = "math.modf(x: number): (number, number)"
documentation = """
返回 `x` 的整数部分和小数部分。

**示例:**
```lua
local int, frac = math.modf(3.14)
-- int is 3, frac is 0.14
```"""
insertText = "modf(${1:x})"

[[math.methods]]
name = "rad"
signature = "math.rad(x: number): number"
documentation = """
将 `x` 从角度转换为弧度。

**示例:**
```lua
print(math.rad(180)) -- 3.14159...
```"""
insertText = "rad(${1:x})"

[[math.methods]]
name = "random"
signature = "math.random(m?: integer, n?: integer): number"
documentation = """
生成伪随机数。
- `random()`: [0,1) 内的浮点数。
- `random(n)`: [1,n] 内的整数。
- `random(m,n)`: [m,n] 内的整数。

**示例:**
```lua
print(math.random(1, 100))
```"""
insertText = "random(${1:m}, ${2:n})"

[[math.methods]]
name = "randomseed"
signature = "math.randomseed(x: number): void"
documentation = """
为伪随机数生成器设置种子 `x`。

**示例:**
```lua
math.randomseed(os.time())
```"""
insertText = "randomseed(${1:seed})"

[[math.methods]]
name = "sqrt"
signature = "math.sqrt(x: number): number"
documentation = """
返回 `x` 的平方根。

**示例:**
```lua
print(math.sqrt(16)) -- 4
```"""
insertText = "sqrt(${1:x})"

[[math.methods]]
name = "tointeger"
signature = "math.tointeger(x: any): integer | nil"
documentation = """
如果 `x` 的值可以转换为整数，则返回该整数；否则返回 `nil`。

**示例:**
```lua
local i = math.tointeger(123.0)
```"""
insertText = "tointeger(${1:x})"

[[math.methods]]
name = "type"
signature = "math.type(x: any): 'integer' | 'float' | nil"
documentation = """
如果 `x` 是整数，返回 "integer"；如果是浮点数，返回 "float"；否则返回 `nil`。

**示例:**
```lua
print(math.type(10)) -- "integer"
print(math.type(10.5)) -- "float"
```"""
insertText = "type(${1:x})"

[[math.methods]]
name = "ult"
signature = "math.ult(m: integer, n: integer): boolean"
documentation = """
如果整数 `m` 小于整数 `n`（无符号比较），则返回 `true`。

**示例:**
```lua
print(math.ult(-1, 0)) -- true,因为 -1 的无符号表示是一个非常大的数
```"""
insertText = "ult(${1:m}, ${2:n})"