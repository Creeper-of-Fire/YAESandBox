{
    "hashes": {
        "launcher": "aebe2ad900ba295356a50e22938f42bcf78673cc1d1036a18598b7bdddd10130",
        "app": "703f81ad84d7701d630a1d6e3e7d1d1cf4aec08c50ef4409f16de0b925b1e0cd",
        "backend": "b26ba7003ec4f7eaa7d41b71da44d151bba98042955fa5342f88be0b2937e896",
        "backend-slim": "f959278a8662e91fed71059f2375f2e6c8b59aa5ae418f0850337244216908cd",
        "plugins": {
            "YAESandBox.Plugin.LuaScript": "78b73919df9a23e759bbddf0d1052267e07a8323e3701c111e4c87d4e0ca08f2",
            "YAESandBox.Plugin.TextParser": "0eb6e6819ed9a834ca547fba3a22f96613f09b5cc53bb40c883c8afdea250d07"
        }
    },
    "manifests": {
        "full": {
            "components": [
                {
                    "id": "launcher",
                    "name": "启动器",
                    "version": "0.0.16",
                    "notes": "重新全部发布一遍试试看。好像文件校验刚刚有问题。",
                    "hash": "00224aabe43bcc8845567e231f62ccc09e8910fda1e56fc2b3bea82fe93815ea",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.16/launcher.zip"
                },
                {
                    "id": "app",
                    "name": "前端应用",
                    "version": "0.0.32",
                    "notes": "## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                    "hash": "a9d198a2f72e1afbd0494c6b89ba7b431e0580e85b86b04c1742f474de338dd5",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/app.zip"
                },
                {
                    "id": "backend",
                    "name": ".NET 后端 (完整版)",
                    "version": "0.0.32",
                    "notes": "## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                    "hash": "7592db7ccb995f08894f212c4f79ab1a674d8258fa0e7ce1bd7c3a5d70d4a948",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/backend.zip"
                }
            ]
        },
        "slim": {
            "components": [
                {
                    "id": "launcher",
                    "name": "启动器",
                    "version": "0.0.16",
                    "notes": "重新全部发布一遍试试看。好像文件校验刚刚有问题。",
                    "hash": "00224aabe43bcc8845567e231f62ccc09e8910fda1e56fc2b3bea82fe93815ea",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.16/launcher.zip"
                },
                {
                    "id": "app",
                    "name": "前端应用",
                    "version": "0.0.32",
                    "notes": "## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                    "hash": "a9d198a2f72e1afbd0494c6b89ba7b431e0580e85b86b04c1742f474de338dd5",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/app.zip"
                },
                {
                    "id": "backend",
                    "name": ".NET 后端 (精简版)",
                    "version": "0.0.32",
                    "notes": "## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                    "hash": "87fcdb546d99341d20f4e862d0f45ded156dca803450ee404d6907e275661a3f",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/backend-slim.zip"
                }
            ]
        },
        "plugins": [
            {
                "id": "YAESandBox.Plugin.LuaScript",
                "name": "YAESandBox.Plugin.LuaScript",
                "version": "0.0.32",
                "description": "发布于 v0.0.32:\n## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                "hash": "428ca9e0c8cae553ce1f2660f0178dca72a66946a14ae69ab04bc137a3f8022a",
                "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/YAESandBox.Plugin.LuaScript.zip"
            },
            {
                "id": "YAESandBox.Plugin.TextParser",
                "name": "YAESandBox.Plugin.TextParser",
                "version": "0.0.32",
                "description": "发布于 v0.0.32:\n## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                "hash": "a98c76cdc04473aed617ada7da059932dc26f32dd105f2383e1ba0383a465164",
                "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/YAESandBox.Plugin.TextParser.zip"
            }
        ]
    }
}