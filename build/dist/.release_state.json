{
    "hashes": {
        "launcher": "2d3468a0c8fb90b3ee8b07a504bea2daf0f88a07d8c3e6bcaf97bafe03e54822",
        "app": "703f81ad84d7701d630a1d6e3e7d1d1cf4aec08c50ef4409f16de0b925b1e0cd",
        "backend": "b26ba7003ec4f7eaa7d41b71da44d151bba98042955fa5342f88be0b2937e896",
        "backend-slim": "f959278a8662e91fed71059f2375f2e6c8b59aa5ae418f0850337244216908cd",
        "plugins": {
            "YAESandBox.Plugin.LuaScript": "bc41e20de357de7240e7fec0b113c4a927eb9fd3d9a87b9282bd5dd3832b20b6",
            "YAESandBox.Plugin.TextParser": "1ade91fa9963d089e34ad7f433f5a465b3e2049a63b13e49533cde7b35e8d4c7"
        }
    },
    "manifests": {
        "full": {
            "components": [
                {
                    "id": "launcher",
                    "name": "启动器",
                    "version": "0.0.33",
                    "notes": "### 版本 0.0.33\n\n我们对启动器的用户界面和底层架构进行了全面的现代化重构。本次更新的核心是引入了全新的侧边栏布局和外观主题系统，旨在提供更清晰、更高效、更具个性化的用户体验。\n\n#### ✨ 主要新增\n\n1.  **全新侧边栏布局**\n    *   **界面彻底重构**: 我们告别了旧的顶部平铺式布局，引入了现代化的侧边栏界面。现在，核心信息、全局操作和设置项被清晰地整合在左侧的固定面板中。\n    *   **信息层级优化**: 这种新布局将应用状态（如“正在初始化...”、“发现更新”）和主要操作（如“启动”、“全部更新”）与右侧滚动的组件列表完全分离，无论组件有多少，关键功能始终触手可及。\n    *   **集成设置面板**: 更新源模式、主题选择和高级设置等所有配置项，现在都被逻辑地组织在新的侧边栏中，查找和修改更加直观。\n\n2.  **应用主题系统 (深色/浅色/跟随系统)**\n    *   启动器现已支持三种主题模式：浅色、深色和跟随系统（默认）。\n    *   您可以在侧边栏的设置面板中轻松切换主题，也可以通过顶部菜单（`视图` -> `主题`）进行更改。\n    *   在 Windows 上，更改主题后会弹出原生对话框，提示您重启应用以获得最佳视觉效果。\n\n3.  **应用菜单增强**\n    *   在 `文件` 菜单中增加了“重启”选项，方便您快速重启启动器。\n    *   在 `视图` 菜单中新增了“主题”子菜单，提供快捷的主题切换方式。\n\n#### 🔧 改进与优化\n\n*   **UI 视觉更新**: 伴随着新布局，我们全面引入了基于 CSS 变量的颜色系统。统一了浅色与深色模式下的按钮、背景、文本、边框等元素的视觉风格，使其更加协调和美观。\n*   **自动刷新组件列表**: 当您在设置中更改了“更新源模式”（例如从“完整版”切换到“精简版”）或在“自定义”模式下修改了 URL 后，组件列表现在会自动刷新，无需手动重启。\n*   **原生重启提示 (Windows)**: 为了解决 Windows 平台无法在运行时完美切换窗口主题的问题，更改主题后会弹出一个原生的、阻塞式的对话框，询问用户是否立即重启，提供了比网页弹窗更好的原生体验。\n\n#### ⚙️ 技术性重构\n\n*   **配置系统彻底重构 (INI -> TOML 解析)**\n    *   **核心变化**: 后端放弃了之前简陋的 INI 字符串解析方式，改为采用强大的 `toml_edit` 库来处理配置文件。虽然文件扩展名仍为 `.config` 以保持兼容性，但内部现在使用更强大、更安全的 TOML 解析器。\n    *   **健壮性**: 新系统实现了“加载或初始化”逻辑。这意味着：\n        1.  如果配置文件不存在，会自动创建一份包含所有默认值和详细注释的全新文件。\n        2.  如果现有配置文件缺少某个键（例如在版本更新后新增的 `theme` 项），启动器会自动补全，而不会破坏用户已有的设置。\n        3.  **旧配置迁移**: 启动器会自动将行首的旧 INI 注释符号（`;`）在内存中转换为标准的 TOML 注释符号（`#`），并进行保存。\n        4.  **损坏恢复**: 如果配置文件因意外修改而损坏导致无法解析，启动器会将其备份为 `.config.bak.{时间戳}` 文件，并重新生成一份默认配置，从而避免了应用无法启动的问题。\n    *   **前后端通信**: 前后端现在通过一个扁平化的 `ConfigEntry` 对象数组来同步配置，取代了之前传递整个文件字符串的方式，更加结构化和一致。\n\n这个版本在用户看得见和看不见的地方都做了大量工作，以确保未来的功能迭代能建立在一个更坚实、更现代化的基础上。希望您喜欢这次全新的界面和体验！",
                    "hash": "7d376e3986fd90b7f0a42d636bee74e44d11104f0b10dc7f21ffdca8f77de4a4",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.33/launcher.zip"
                },
                {
                    "id": "app",
                    "name": "前端应用",
                    "version": "0.0.32",
                    "notes": "## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                    "hash": "a9d198a2f72e1afbd0494c6b89ba7b431e0580e85b86b04c1742f474de338dd5",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/app.zip"
                },
                {
                    "id": "backend",
                    "name": ".NET 后端 (完整版)",
                    "version": "0.0.32",
                    "notes": "## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                    "hash": "7592db7ccb995f08894f212c4f79ab1a674d8258fa0e7ce1bd7c3a5d70d4a948",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/backend.zip"
                }
            ]
        },
        "slim": {
            "components": [
                {
                    "id": "launcher",
                    "name": "启动器",
                    "version": "0.0.33",
                    "notes": "### 版本 0.0.33\n\n我们对启动器的用户界面和底层架构进行了全面的现代化重构。本次更新的核心是引入了全新的侧边栏布局和外观主题系统，旨在提供更清晰、更高效、更具个性化的用户体验。\n\n#### ✨ 主要新增\n\n1.  **全新侧边栏布局**\n    *   **界面彻底重构**: 我们告别了旧的顶部平铺式布局，引入了现代化的侧边栏界面。现在，核心信息、全局操作和设置项被清晰地整合在左侧的固定面板中。\n    *   **信息层级优化**: 这种新布局将应用状态（如“正在初始化...”、“发现更新”）和主要操作（如“启动”、“全部更新”）与右侧滚动的组件列表完全分离，无论组件有多少，关键功能始终触手可及。\n    *   **集成设置面板**: 更新源模式、主题选择和高级设置等所有配置项，现在都被逻辑地组织在新的侧边栏中，查找和修改更加直观。\n\n2.  **应用主题系统 (深色/浅色/跟随系统)**\n    *   启动器现已支持三种主题模式：浅色、深色和跟随系统（默认）。\n    *   您可以在侧边栏的设置面板中轻松切换主题，也可以通过顶部菜单（`视图` -> `主题`）进行更改。\n    *   在 Windows 上，更改主题后会弹出原生对话框，提示您重启应用以获得最佳视觉效果。\n\n3.  **应用菜单增强**\n    *   在 `文件` 菜单中增加了“重启”选项，方便您快速重启启动器。\n    *   在 `视图` 菜单中新增了“主题”子菜单，提供快捷的主题切换方式。\n\n#### 🔧 改进与优化\n\n*   **UI 视觉更新**: 伴随着新布局，我们全面引入了基于 CSS 变量的颜色系统。统一了浅色与深色模式下的按钮、背景、文本、边框等元素的视觉风格，使其更加协调和美观。\n*   **自动刷新组件列表**: 当您在设置中更改了“更新源模式”（例如从“完整版”切换到“精简版”）或在“自定义”模式下修改了 URL 后，组件列表现在会自动刷新，无需手动重启。\n*   **原生重启提示 (Windows)**: 为了解决 Windows 平台无法在运行时完美切换窗口主题的问题，更改主题后会弹出一个原生的、阻塞式的对话框，询问用户是否立即重启，提供了比网页弹窗更好的原生体验。\n\n#### ⚙️ 技术性重构\n\n*   **配置系统彻底重构 (INI -> TOML 解析)**\n    *   **核心变化**: 后端放弃了之前简陋的 INI 字符串解析方式，改为采用强大的 `toml_edit` 库来处理配置文件。虽然文件扩展名仍为 `.config` 以保持兼容性，但内部现在使用更强大、更安全的 TOML 解析器。\n    *   **健壮性**: 新系统实现了“加载或初始化”逻辑。这意味着：\n        1.  如果配置文件不存在，会自动创建一份包含所有默认值和详细注释的全新文件。\n        2.  如果现有配置文件缺少某个键（例如在版本更新后新增的 `theme` 项），启动器会自动补全，而不会破坏用户已有的设置。\n        3.  **旧配置迁移**: 启动器会自动将行首的旧 INI 注释符号（`;`）在内存中转换为标准的 TOML 注释符号（`#`），并进行保存。\n        4.  **损坏恢复**: 如果配置文件因意外修改而损坏导致无法解析，启动器会将其备份为 `.config.bak.{时间戳}` 文件，并重新生成一份默认配置，从而避免了应用无法启动的问题。\n    *   **前后端通信**: 前后端现在通过一个扁平化的 `ConfigEntry` 对象数组来同步配置，取代了之前传递整个文件字符串的方式，更加结构化和一致。\n\n这个版本在用户看得见和看不见的地方都做了大量工作，以确保未来的功能迭代能建立在一个更坚实、更现代化的基础上。希望您喜欢这次全新的界面和体验！",
                    "hash": "7d376e3986fd90b7f0a42d636bee74e44d11104f0b10dc7f21ffdca8f77de4a4",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.33/launcher.zip"
                },
                {
                    "id": "app",
                    "name": "前端应用",
                    "version": "0.0.32",
                    "notes": "## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                    "hash": "a9d198a2f72e1afbd0494c6b89ba7b431e0580e85b86b04c1742f474de338dd5",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/app.zip"
                },
                {
                    "id": "backend",
                    "name": ".NET 后端 (精简版)",
                    "version": "0.0.32",
                    "notes": "## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                    "hash": "87fcdb546d99341d20f4e862d0f45ded156dca803450ee404d6907e275661a3f",
                    "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/backend-slim.zip"
                }
            ]
        },
        "plugins": [
            {
                "id": "YAESandBox.Plugin.LuaScript",
                "name": "YAESandBox.Plugin.LuaScript",
                "version": "0.0.32",
                "description": "发布于 v0.0.32:\n## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                "hash": "428ca9e0c8cae553ce1f2660f0178dca72a66946a14ae69ab04bc137a3f8022a",
                "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/YAESandBox.Plugin.LuaScript.zip"
            },
            {
                "id": "YAESandBox.Plugin.TextParser",
                "name": "YAESandBox.Plugin.TextParser",
                "version": "0.0.32",
                "description": "发布于 v0.0.32:\n## v0.0.32: 紧急修复与全新工作流持久化架构\n\n这是一个包含**关键 Bug 修复**和**全新后端架构**的混合版本。由于修复的 Bug 极端严重，我们决定立即发布 v0.0.32，尽管其中包含的全新持久化系统尚未在前端完全集成并存在已知局限。\n\n### 🚨 **重大 Bug 修复 (Critical Fix)**\n\n**fix(schema): 优先处理字段级自定义渲染器**\n\n我们修正了一个极端恶性的 Bug，该 Bug 会导致配置了自定义渲染器的对象在前端表单中**完全消失**，从而无法进行任何编辑。\n\n*   **问题根源**: 前端 Schema 处理逻辑的优先级错误。当一个对象本身被指定了自定义渲染器时，系统没有优先采用该渲染器，而是错误地继续处理其内部属性。\n*   **问题加剧**: 旧的 `RenderAsCustomObjectWidgetAttribute` 机制会在后端生成 Schema 时，主动删除该对象的所有子属性定义。\n*   **最终影响**: 这两个问题结合，导致前端既无法应用顶层的自定义渲染器，也找不到任何子属性来作为“后备”进行渲染。最终结果就是整个字段在 UI 上彻底消失，相关功能完全无法使用。\n*   **解决方案**:\n    *   调整了 Schema 处理逻辑，**确保字段级的自定义渲染器指令拥有最高优先级**。\n    *   彻底移除了有问题的 `RenderAsCustomObjectWidgetAttribute` 及其处理器，统一使用 `RenderWithCustomWidget` 特性，确保 Schema 结构的完整性。\n\n这个 Bug 虽然修复起来很简单，但其影响是毁灭性的。我们为未能及时发现此问题深表歉意。**此修复是本次发布的唯一且首要的原因**。\n\n---\n\n### 🚀 **新特性：全新工作流持久化与执行上下文系统**\n\n在本次发布中，我们从零开始设计并实现了一套全新的工作流持久化系统，旨在为工作流提供幂等性、可恢复性和更强的可追溯性。\n\n#### **1. 核心设计：兼具便捷与灵活的持久化 API**\n\n我们提供了一套分层的 API，以适应不同的使用场景：\n\n*   **推荐的主力用法：Fluent API**\n    对于绝大多数场景，我们强烈推荐使用简洁、安全的 fluent API。它将所有持久化操作封装在一个原子化的 `PersistenceOperation` 单元中，通过链式调用完成，代码意图明确且极为简洁：\n    ```csharp\n    return await persistenceService.WithPersistence(id, inputs).ExecuteAsync(logic).RunAsync();\n    ```\n\n*   **高级用例：手动控制 API**\n    **fluent API 是对底层手动调用流程的精心封装**。对于需要更精细控制的复杂场景，开发者依旧可以手动调用底层的各个方法，来控制检查、执行和保存的每一步。\n\n#### **2. 健壮的架构支撑**\n\n*   **状态机模式**: 实例状态（`RunningState`, `CompletedState`, `FailedState`）通过 C# 的密封 `record` 体系实现，构成了一个严格的辨别联合，从设计上杜绝了无效状态。\n*   **可靠的 `null` 值序列化**: 新增 `ValueWrapper<T>` 工具类，解决了无法区分有效 `null` 结果和数据损坏的难题。\n*   **统一的执行上下文 (`ProcessorContext`)**: 重构了处理器的创建和依赖管理，通过 `ProcessorContext` 和 `ICreatingContext` 确保了执行链的清晰与正确。\n*   **开箱即用的文件持久化**: 本次发布包含了 `JsonFilePersistenceStorage` 的实现，采用单文件聚合策略。\n\n#### **3. 已知局限 (Known Limitation)**\n\n我们注意到，当前的持久化实现在序列化 `Error` 类型时可能存在 Bug。\n\n*   **影响**: 如果一个被持久化的步骤执行失败，其具体的错误信息（`Error` 对象）可能无法被正确地保存下来，甚至导致工作流抛出异常。\n*   **当前考量**: 对于本次紧急发布而言，这是一个可以接受的暂时性问题。因为工作流在遇到错误时本就会中断执行，此 Bug 不会改变最终的执行结果。**我们的首要任务是确保在全 `Result` 成功路径下的持久化功能能够稳定运行**，以便让关键修复尽快上线。\n\n#### **4. 为未来奠定基础**\n\n新架构明确了 `WorkflowPersistenceService` 的核心职责——**它是一个纯粹的计算状态缓存**。副作用、调试等横切关注点将被剥离到未来的专属服务中，为构建一个真正可观测、可审计的系统铺平了道路。\n\n---\n\n**请立即升级以获取关键的渲染器 Bug 修复！**",
                "hash": "a98c76cdc04473aed617ada7da059932dc26f32dd105f2383e1ba0383a465164",
                "url": "https://github.com/Creeper-of-Fire/YAESandBox/releases/download/v0.0.32/YAESandBox.Plugin.TextParser.zip"
            }
        ]
    }
}