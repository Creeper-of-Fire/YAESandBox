**YAESandBox 前端BlockBubble设计总结**

**1. 应用形态:**

*   一个**单页面 Web 应用程序 (Single-Page Application, SPA)**，在浏览器单个标签页内运行。

**2. 核心视图与布局:**

*   **中央主区域:** 固定区域，用于展示核心的**垂直无限滚动 Block 流**。每个元素是一个 `BlockBubble`，类似聊天记录或论坛楼层。
*   **灵活面板系统:** 应用界面提供多个可用的“面板插槽”（如左侧、右侧、顶部工具栏下方区域）。这些插槽用于动态加载和显示各种功能面板。布局并非固定三栏，而是由用户按需配置。
*   **符文化组件:** 各种功能（如 Block 详情查看器、实体列表、GameState 编辑器、元数据编辑器、冲突解决器、生成设置面板等）被封装为独立的 UI 组件。用户可以通过顶部工具栏、Block 上的快捷操作或其他交互方式，将这些组件加载到不同的面板插槽中，或将其隐藏/关闭。

**3. 核心组件 (`BlockBubble` & `SiblingPager`):**

*   **`BlockBubble`:**
    *   中栏 Block 流的基本单元。
    *   显示对应 Block 的**完整 `blockContent`**。内容可能很长，组件内部需处理滚动或提供折叠/展开机制。
    *   包含用于**触发生成下一个 Block** 的交互控件（例如按钮、输入区域等），该控件与当前 `BlockBubble` 关联。
    *   内嵌**极简化的 `SiblingPager` 控件**。
*   **`SiblingPager`:**
    *   外观极简，仅显示**页码信息**（如“分支 2/5”）和**左右翻页按钮 (`<`, `>`)**。
    *   **翻页即时切换主路径分支:** 点击翻页按钮会**立即**更新当前 `BlockBubble` 显示的内容为翻到的那个兄弟节点，并动态调整该气泡下方的后续 Block 视图。**切换并非废弃旧路径**，只是改变当前视图的焦点和路径选择状态。

**4. 主要交互流程:**

*   **浏览与探索:** 用户通过中栏上下滚动浏览主路径。通过 `SiblingPager` 的翻页按钮无缝、即时地切换到不同的分支进行探索。
*   **生成新节点:** 在某个 `BlockBubble` 内部的特定控件触发 `TriggerMainWorkflow`，在其下方生成一个新的 `BlockBubble` 作为当前路径的延伸。
*   **编辑流程:**
    *   通过某种方式（例如 `BlockBubble` 上的快捷按钮或右键菜单）触发，将“实体编辑器”组件加载到某个面板插槽。
    *   在编辑器中选择实体，修改属性。
    *   完成后点击“保存更改”，调用 `POST /api/atomic/{blockId}` 将原子操作提交给**对应的 Block**。
*   **AI 辅助编辑 ("润色"):** 在实体编辑器的字符串属性旁提供 ✨ 按钮，点击调用 `TriggerMicroWorkflow`（后端负责上下文），结果通过 `ReceiveDisplayUpdate`（带 `targetElementId`）直接更新对应输入框。
*   **重新生成:** 触发对一个**已存在** Block 的内容和状态进行重新生成，但**保持其子节点结构不变**（逻辑一致性由用户或工作流承担）。

**5. 状态管理与数据处理:**

*   **前端维护路径选择:** 前端使用类似 `Map<parentId, selectedChildId>` 的机制，记录在每个父节点下，当前主路径选择了哪个子节点。这是决定中栏视图的关键状态。
*   **盲存用于路径恢复:** 保存会话时，前端将**每个路径的最底层叶节点 ID **以及**当前路径的最底层叶节点 ID ** 存入盲存数据。加载会话时，前端利用此 ID 和后端恢复的 Block 数据，通过回溯父节点引用来重建用户上次查看的完整主路径。
*   **客户端图结构:** 前端在加载或数据更新后，解析后端提供的 `topology` 和 `blocks` 数据，构建便于快速查找父、子、兄弟关系的内存数据结构（例如 `Map<string, ProcessedBlockInfo>`）。

**6. 内容渲染 (`blockContent`):**

*   **统一访问:** 实现 `getContentToRender()` 函数，优先返回脚本处理后的 `processedContent`，若无则返回 `originalContent`（均为只读访问）。
*   **解析与渲染:** 对 `getContentToRender()` 返回的内容进行处理：
    *   **分块:** 按预定规则（如双换行符）分割内容。
    *   **格式识别:** 识别并提取 ` ```<format>...</format>``` ` 格式块。
    *   **渲染:** 根据 `<format>` 调用相应的渲染库（Markdown、代码高亮等）。普通文本直接显示。
*   **脚本执行 (可选):** 如果 `DisplayUpdateDto` 包含 `script` 字符串，前端直接执行该脚本（**用户自行承担安全风险**），其输出作为 `processedContent`。


**7. 核心原则与风格:**

*   **直接性与效率:** 避免不必要的 UI 动画，追求即时反馈和操作效率。
*   **探索性:** 鼓励用户通过简化的 Pager 轻松探索所有叙事可能性。
*   **持久性:** Block 世界图是持久的，用户交互只是改变当前的“视点”或对其进行修改/扩展。
*   **灵活性与可配置性:** 通过灵活的面板系统提供用户自定义界面的能力。
*   **用户责任:** 用户负责本地部署的脚本执行安全，以及重新生成操作可能带来的逻辑一致性问题。
*   **前后端责任分离:** 后端提供数据、结构、操作和核心逻辑；前端负责视图渲染、交互逻辑、当前路径选择状态和与后端通信。

**YAESandBox 工作流编辑器设计草图**

**1. 核心交互流程：基于变量的智能编辑**

前端的核心任务是为用户提供一个“**智能感知**”的编辑环境，让变量的流动像编写代码一样自然。**我们不使用显式的“连连看”节点图。**

*   **变量的产生 (Production):**
    *   当用户在右侧面板配置一个符文时（如`PromptGenerationRune`），可以为其`produces`字段添加输出变量名（如 `welcome_text`）。
    *   当用户配置一个枢机时，其`OutputMappings`配置UI会自动收集该枢机内所有符文产生的**局部变量**。用户可以通过**勾选和重命名**的方式，决定哪些局部变量要被发布为**全局变量**。

*   **变量的消费 (Consumption):**
    *   **智能自动完成:** 当用户在右侧面板点击一个符文的`consumes`输入框，或在模板字符串中输入`{`时，前端会弹出一个**自动完成列表**。
    *   **上下文感知列表:** 这个列表**只会显示在当前编辑枢机执行前，理论上已经可用的全局变量**。前端通过分析所有在当前枢机**之前**的枢机的`OutputMappings`来实时计算这个可用变量列表。
    *   **数据流可视化 (可选，非连线):** 前端可以在变量名旁边显示一个小图标或提示，点击后可以**高亮**所有消费和生产该变量的枢机，从而无需连线也能清晰地追溯数据来源和去向。

*   **实时静态分析与反馈:**
    *   前端在后台**持续地、非阻塞地**分析整个工作流配置。
    *   **错误提示:** 如果一个符文消费了一个不存在的变量，或者一个枢机的`OutputMappings`映射了一个其内部并不产生的局部变量，前端会在对应的UI元素上显示一个**红色的波浪线或错误图标**，并提供详细的错误信息。
    *   **警告提示:** 如果一个全局变量被多个无依赖关系的枢机写入（可能导致竞争），前端可以给出黄色警告，提示用户这可能导致不可预测的结果，建议调整枢机顺序或变量名。
    *   **宽容保存:** 即使配置存在错误或警告，用户**依然可以保存**，确保创作流程不被打断。

**2. 状态管理与数据处理:**

*   **前端即编译器:** 前端在内存中维护着整个工作流的依赖图和变量作用域信息，它扮演着一个轻量级编译器的角色，为用户提供即时反馈。
*   **API 交互:**
    *   **启动时:** 调用`GET /api/v1/workflows-configs/global-runes/all-rune-configs-schemas`获取所有符文的配置结构。
    *   **编辑时:** 实时构建符合`WorkflowConfig`结构的JSON对象。
    *   **保存时:** 调用`PUT /api/v1/workflows-configs/global-workflows/{workflowId}`将完整的JSON配置发送到后端。**后端信任前端已经完成了大部分逻辑校验,即使是暂时错误的草稿也可以保存**。

**3. 核心原则与风格:**

*   **代码即画布 (Code as Canvas):** 提供一种接近于编写高级脚本的、流畅的创作体验，而不是繁琐的节点连接。
*   **智能引导:** 通过上下文感知的自动完成和实时错误检测，主动引导用户创建出逻辑正确的工作流。
*   **清晰的边界:** 明确区分**局部变量**（符文内部、枢机内部）和**全局变量**（枢机间传递），并通过`OutputMappings` UI让用户掌控这一边界。
*   **性能优先:** 避免复杂的2D画布渲染，采用轻量级的列表和表单，确保大规模工作流的流畅编辑体验。
*   **用户责任:** 用户负责设计清晰的数据流。当出现竞争条件时，他们需要通过调整枢机的**物理顺序**来解决歧义，这是一种简单而直观的冲突解决方法。